<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- saved from url=(0053)http://www.virtualdub.org/blog/pivot/entry.php?id=120 -->
<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><TITLE>Writing custom visualizers for Visual Studio 2005 - virtualdub.org</TITLE><LINK rel="stylesheet" type="text/css" href="./Writing custom visualizers for Visual Studio 2005 - virtualdub.org_files/layout.css"> <LINK rel="alternate" type="application/rss+xml" title="RSS" href="http://www.virtualdub.org/blog/rss.xml"> <LINK rel="alternate" type="application/atom+xml" title="Atom" href="http://www.virtualdub.org/blog/atom.xml"> <!-- snippet 'calendar-style' is not defined --></HEAD><BODY><TABLE class="banner" border="0" cellpadding="0" cellspacing="0"><TBODY><TR><TD width="100%"><SPAN style="font-family: arial, helvetica; font-size: 20pt"><A href="http://www.virtualdub.org/" style="color: #000000; text-decoration: none">virtualdub.org</A></SPAN><BR> Proof that I had too much free time in college</TD><TD align="right"><A href="http://www.robofish.com/cgi-bin/banner.cgi?virtualdub"><IMG border="1" width="468" height="60" src="./Writing custom visualizers for Visual Studio 2005 - virtualdub.org_files/banner.cgi" alt="[TealPoint Software Ad]"></A></TD></TR></TBODY></TABLE><DIV id="leftcolumn"><DIV class="block"> <H3>Current version</H3> <P> v1.9.6 (stable)</P></DIV> <DIV class="block"> <H3>Navigation</H3> <A href="http://www.virtualdub.org/index.html">Main page</A><BR> <A href="http://www.virtualdub.org/oldnews.html">Archived news</A><BR> <A href="http://www.virtualdub.org/download.html">Downloads</A><BR> <A href="http://www.virtualdub.org/virtualdub_docs.html">Documentation</A><BR> &nbsp;&nbsp;&nbsp;<A href="http://www.virtualdub.org/docs_capture.html">Capture</A><BR> &nbsp;&nbsp;&nbsp;<A href="http://www.virtualdub.org/docs_compiling.html">Compiling</A><BR> &nbsp;&nbsp;&nbsp;<A href="http://www.virtualdub.org/docs_processing.html">Processing</A><BR> &nbsp;&nbsp;&nbsp;<A href="http://www.virtualdub.org/docs_crashes.html">Crashes</A><BR> <A href="http://www.virtualdub.org/features.html">Features</A><BR> <A href="http://www.virtualdub.org/virtualdub_filters.html">Filters</A><BR> <A href="http://www.virtualdub.org/filtersdk.html">Plugin SDK</A><BR> <A href="http://www.virtualdub.org/virtualdub_kb.html">Knowledge base</A><BR> <A href="http://www.virtualdub.org/donation.html">Donate</A><BR> <A href="http://www.virtualdub.org/contact.html">Contact info</A><BR> <A href="http://forums.virtualdub.org/">Forum</A><BR> &nbsp; <BR> Other projects<BR> &nbsp;&nbsp;&nbsp;<A href="http://www.virtualdub.org/altirra.html">Altirra</A><BR></DIV></DIV> <DIV id="rightcolumn"> <DIV class="block"> <H3>Search</H3> <FORM method="post" action="http://www.virtualdub.org/blog/pivot/search.php">
<INPUT type="text" name="search" class="searchbox" value="">
<INPUT type="submit" class="searchbutton" value="go!">
</FORM>
</DIV> <DIV class="block"> <H3>Archives</H3> <P><A href="http://www.virtualdub.org/blog/archives/archive_2009-m10.php">01 Oct - 31 Oct 2009 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2009-m09.php">01 Sep - 30 Sep 2009 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2009-m08.php">01 Aug - 31 Aug 2009 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2009-m07.php">01 Jul - 31 Jul 2009 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2009-m06.php">01 June - 30 June 2009 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2009-m05.php">01 May - 31 May 2009 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2009-m04.php">01 Apr - 30 Apr 2009 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2009-m03.php">01 Mar - 31 Mar 2009 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2009-m02.php">01 Feb - 29 Feb 2009 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2009-m01.php">01 Jan - 31 Jan 2009 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2008-m12.php">01 Dec - 31 Dec 2008 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2008-m11.php">01 Nov - 30 Nov 2008 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2008-m10.php">01 Oct - 31 Oct 2008 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2008-m09.php">01 Sep - 30 Sep 2008 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2008-m08.php">01 Aug - 31 Aug 2008 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2008-m07.php">01 Jul - 31 Jul 2008 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2008-m06.php">01 June - 30 June 2008 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2008-m05.php">01 May - 31 May 2008 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2008-m04.php">01 Apr - 30 Apr 2008 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2008-m03.php">01 Mar - 31 Mar 2008 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2008-m02.php">01 Feb - 29 Feb 2008 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2008-m01.php">01 Jan - 31 Jan 2008 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2007-m12.php">01 Dec - 31 Dec 2007 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2007-m11.php">01 Nov - 30 Nov 2007 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2007-m10.php">01 Oct - 31 Oct 2007 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2007-m09.php">01 Sep - 30 Sep 2007 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2007-m08.php">01 Aug - 31 Aug 2007 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2007-m07.php">01 Jul - 31 Jul 2007 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2007-m06.php">01 June - 30 June 2007 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2007-m05.php">01 May - 31 May 2007 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2007-m04.php">01 Apr - 30 Apr 2007 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2007-m03.php">01 Mar - 31 Mar 2007 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2007-m02.php">01 Feb - 29 Feb 2007 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2007-m01.php">01 Jan - 31 Jan 2007 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2006-m12.php">01 Dec - 31 Dec 2006 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2006-m11.php">01 Nov - 30 Nov 2006 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2006-m10.php">01 Oct - 31 Oct 2006 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2006-m09.php">01 Sep - 30 Sep 2006 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2006-m08.php">01 Aug - 31 Aug 2006 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2006-m07.php">01 Jul - 31 Jul 2006 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2006-m06.php">01 June - 30 June 2006 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2006-m05.php">01 May - 31 May 2006 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2006-m04.php">01 Apr - 30 Apr 2006 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2006-m03.php">01 Mar - 31 Mar 2006 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2006-m02.php">01 Feb - 29 Feb 2006 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2006-m01.php">01 Jan - 31 Jan 2006 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2005-m12.php">01 Dec - 31 Dec 2005 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2005-m11.php">01 Nov - 30 Nov 2005 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2005-m10.php">01 Oct - 31 Oct 2005 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2005-m09.php">01 Sep - 30 Sep 2005 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2005-m08.php">01 Aug - 31 Aug 2005 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2005-m07.php">01 Jul - 31 Jul 2005 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2005-m06.php">01 June - 30 June 2005 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2005-m05.php">01 May - 31 May 2005 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2005-m04.php">01 Apr - 30 Apr 2005 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2005-m03.php">01 Mar - 31 Mar 2005 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2005-m02.php">01 Feb - 29 Feb 2005 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2005-m01.php">01 Jan - 31 Jan 2005 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2004-m12.php">01 Dec - 31 Dec 2004 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2004-m11.php">01 Nov - 30 Nov 2004 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2004-m10.php">01 Oct - 31 Oct 2004 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2004-m09.php">01 Sep - 30 Sep 2004 </A><BR><A href="http://www.virtualdub.org/blog/archives/archive_2004-m08.php">01 Aug - 31 Aug 2004 </A><BR></P></DIV> <DIV class="block"> <H3>Stuff</H3> <P><A href="http://www.pivotlog.net/?ver=Pivot+-+1.15%3A+%27Soundwave%27" title="Powered by Pivot - 1.15: &#39;Soundwave&#39;"><IMG src="./Writing custom visualizers for Visual Studio 2005 - virtualdub.org_files/pivotbutton.png" width="94" height="15" alt="Powered by Pivot" style="border:0;"></A> &nbsp;<BR> <A href="http://www.virtualdub.org/blog/rss.xml" title="XML: RSS feed"><IMG src="./Writing custom visualizers for Visual Studio 2005 - virtualdub.org_files/rssbutton.png" width="94" height="15" alt="XML: RSS feed" style="border:0px;"></A>&nbsp;<BR> <A href="http://www.virtualdub.org/blog/atom.xml" title="XML: Atom feed"><IMG src="./Writing custom visualizers for Visual Studio 2005 - virtualdub.org_files/atombutton.png" width="94" height="15" alt="XML: Atom feed" style="border:0px;"></A>&nbsp;<BR></P></DIV></DIV> <DIV id="centercolumn"> <DIV class="content"> <H2 style="clear:both;"><SPAN class="date"><A href="http://www.virtualdub.org/blog/archives/archive_2006-m07.php#e120" title="Permanent link to &#39;Writing custom visualizers for Visual Studio 2005&#39; in the archives">§</A> <A href="./Writing custom visualizers for Visual Studio 2005 - virtualdub.org_files/Writing custom visualizers for Visual Studio 2005 - virtualdub.org.htm" title="Permanent link to entry &#39;Writing custom visualizers for Visual Studio 2005&#39;">¶</A></SPAN>Writing custom visualizers for Visual Studio 2005</H2> <P>The native debugger in Visual&nbsp;Studio has long had an underadvertised feature called <EM>autoexp.dat</EM>, which is a file in the PackagesDebugger folder that allows you to control several aspects of the debugger. Among the features that you can control in autoexp.dat include: the string that is displayed for types in the variable panes, which functions the debugger will skip when stepping, and string names for COM HRESULTs. The first is the most interesting and useful, but unfortunately it doesn't support complex expressions. If you try to access more than one field in an expression:</P>
<P>MyType=size=&lt;m_last - m_first, i&gt;</P>
<P>...the debugger simply displays ??? instead. You can get around these limitations by writing an expression evaluator plugin, which can read any process memory, but in the end you're still limited to outputing only a single short string.</P>
<P>In Visual Studio 2005, a powerful feature has been added to <EM>autoexp.dat</EM> in the form of the [Visualizer] section. This section too contains mappings from types to display form, but these have a whole language for evaluating the object -- and unlike the regular [AutoExpand] templates, you can also affect the <EM>contents</EM> when the object is expanded. This means you can actually view the contents of an STL set, not just see raw red/black tree nodes.</P>
<P>Now, the [Visualizer] section is undocumented, and there's a comment at the top of the section that says DO NOT MODIFY. For those of you who are new to Windows programming, that means "edit at will." The problem is then deciphering the visualizer language.</P>
<P>P.S. Back up autoexp.dat before proceeding.</P> <P><STRONG>Basic structure</STRONG></P>
<P>A visualizer's basic structure is as follows:</P>
<BLOCKQUOTE dir="ltr" style="MARGIN-RIGHT: 0px"><PRE><EM>typename[</EM>|<EM>typename...]</EM> {
    preview (
        <EM>preview-string-expression</EM>
    )
    stringview (
        <EM>text-visualizer-expression</EM>
    )
    children (
        <EM>expanded-contents-expression</EM>
    )
}</PRE></BLOCKQUOTE>
<P>All three of these expressions are optional.</P>
<P>Like the AutoExpand templates, it is possible to match templates by using <EM>type&lt;*&gt;</EM> syntax, and also possible to do partial template matches, i.e. <EM>Foo&lt;Bar, *&gt;</EM>. The template parameters will show up as <EM>$T1, $T2, </EM>etc. You can also supply multiple types using <EM>Foo|Bar</EM> syntax.</P>
<P><EM>autoexp.dat</EM> is reloaded every time the debugger starts. It is not necessary to restart Visual Studio to see changes; restarting the debugger, or detaching and reattaching to the target, is sufficient to effect changes.</P>
<P><STRONG>The preview expression</STRONG></P>
<P>The preview expression consists of a single&nbsp;expression to display in the one-line preview of a variable in Watch, QuickWatch, or the Command Window. This can either be a literal string or an expression, which is surrounded in brackets if it contains a formatting specifier. Unlike AutoExpand, however, the expression must dereference the current object using the <EM>$c</EM> variable. Since a single expression isn't usually useful, you will want to use <EM>#(</EM> and <EM>)</EM> to bracket a comma-delimited list of strings and expressions.</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>// code
template&lt;class T&gt; struct MyType {
    T *start, *end;
};
// autoexp.dat
MyType&lt;*&gt; {
    preview (
        #(
            "ptr=", (void *)$c.start, ", size=", [$c.end-$c.start, i]
        )
    )
}
</PRE></BLOCKQUOTE>
<P>The parser isn't very robust and you'll often get weird results if you make mistakes. So don't do that. Another downer with regard to expressions here is that the <EM>sizeof()</EM> keyword doesn't work, which is unfortunate for template visualizers. Finally, colons, parens,&nbsp;and brackets within string and character literals can confuse the parser and give you inexplicable mismatch failures.</P>
<P><STRONG>Displaying children</STRONG></P>
<P>Now, for the real meat of the visualizer: showing children.</P>
<P>The <EM>children</EM> block also expects either a single item or a <EM>#()</EM> delimited list of items; when present, the object will have a [+] next to it and the expanded view will show the contents produced by this block. Each expression will show up as ascending indices, i.e. [0], [1], [2], etc. You can also name specific elements using <EM>name : expr</EM> syntax; the rules for the name are a little looser than&nbsp;C identifiers, with brackets in particular being accepted.&nbsp;The order of named fields is irrelevant; the contents are always sorted.</P>
<P>Example:</P>
<BLOCKQUOTE><PRE>MyType&lt;*&gt; {
    children (
        #(
            ptr: (void *)$c.start,<BR>            [size]: [$c.end-$c.start, i]
        )
    )
}
</PRE></BLOCKQUOTE>
<P>The ability of a visualizer to construct hierarchies in the watch window is limited. For the most part, you can only add items immediately below the item being visualized; the only ways available to add expandable objects is either to reference an aggregate or other object with a visualizer, or to use an array expression, i.e. <EM>[$c.start, 4x]</EM>.</P>
<P>Note that the contents of the children block will replace the struct fields that would normally be displayed. It's a good idea to leave yourself an escape hatch by including a field with the value <EM>[$c,!]</EM>, whose&nbsp;expanded view&nbsp;re-evaluates the current object without any visualizers or AutoExpand expressions.</P>
<P><STRONG>Arrays</STRONG></P>
<P>Being able to plop new fields in is neat, but the above doesn't allow you to view the contents of the data structure, which is hidden between those two pointers. Enter the <EM>#array</EM> statement:</P>
<BLOCKQUOTE><PRE>MyType&lt;*&gt; {
    children (
        #(<BR>            [raw members]: [$c,!],
            [size]: [$c.end-$c.start, i],
            #array (
                expr: $c.start[$i],
                size: $c.end - $c.start
            )
        )
    )
}</PRE></BLOCKQUOTE>
<P>Here's what it looks like in the debugger:</P>
<P style="text-align:center;"><IMG src="./Writing custom visualizers for Visual Studio 2005 - virtualdub.org_files/debuggervector.png" border="0" title="[Custom vector in debugger]" alt="[Custom vector in debugger]"></P>
<P>The <EM>#array</EM> statement looks like it evaluates an array. Actually, it doesn't -- all it does is count the <EM>$i</EM> variable up from 0 to <EM>size-1</EM>, which you can then use in the <EM>expr</EM> field. This is actually better, because you can use it to evaluate chunked or triangular arrays. You don't even have to evaluate fields at all; you could generate a table with it if you were sufficiently bored. Any fields generated from <EM>#array</EM> are unnamed and will appear as ascending indices.</P>
<P>It is also possible to customize the value display for the array, by supplying an&nbsp;expression after the <EM>#array</EM> statement. The <EM>$e</EM> variable&nbsp;is set to the value produced by <EM>expr</EM> for that element.&nbsp;For instance, to display the address of each element in the data structure:</P>
<BLOCKQUOTE dir="ltr" style="MARGIN-RIGHT: 0px"><PRE>MyType&lt;*&gt; {<BR>&nbsp;&nbsp;&nbsp; children (<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [size]: [$c.end-$c.start, i],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #array (<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expr: $c.start[$i],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size: $c.end - $c.start<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) : &amp;$e<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<BR>&nbsp;&nbsp;&nbsp; )<BR>}</PRE></BLOCKQUOTE>
<P>The bummer about doing this is that any other fields that you include will bump the indices produced by the array. I haven't found a way around this, yet. If you wrap the value expression in&nbsp;a nested <EM>#()</EM> it is possible to override the name for each element, although the name will be same for all elements. Also, if you supply multiple items per element, all of them will show up. If they're unnamed they'll get successive indices, so the first element will produce [0] and [1], the second [2] and [3], etc. One use for this is to display a packed&nbsp;array of 4-bit fields.</P>
<P>There are two additional options for <EM>#array</EM>: the&nbsp;<EM>base</EM> and <EM>rank</EM>&nbsp;fields. The <EM>base</EM> field allows you to change the starting array index. It doesn't change <EM>$i</EM>, but it does offset the array indices shown. (This only works if you don't override the display for <EM>$e</EM>, in which case single incrementing indices&nbsp;are always used.) The <EM>rank</EM> field allows you to do regular multi-dimensional arrays; when it is present and evaluates to greater than one, the <EM>size</EM> and<EM>&nbsp;base</EM> expressions&nbsp;are evaluated multiple times with <EM>$r</EM> indicating the zero-based dimension, and <EM>expr</EM> is then evaluated once for (product of all <EM>size</EM>) times with <EM>$i</EM> counting up contiguously. Thus:</P>
<BLOCKQUOTE dir="ltr" style="MARGIN-RIGHT: 0px"><PRE>// code<BR>struct MyArray2D {<BR>&nbsp;&nbsp;&nbsp; T *start;<BR>    int innerSize;<BR>    int outerSize;<BR>};</PRE><PRE>// autoexp.dat<BR>MyArray2D {<BR>&nbsp;&nbsp;&nbsp; children (<BR>        #array (<BR>            expr: $c.start[$i],<BR>            rank: 2,<BR>            size: ($r==1)*$c.outerSize+($r==0)*$c.innerSize,<BR>            base: 1<BR>        )<BR>&nbsp;&nbsp;&nbsp; )<BR>}</PRE></BLOCKQUOTE>
<P>Sadly, the order of indices is reversed in the names produced, i.e [1,1], [2,1], [3,1], etc. If you don't mind the wonked ordering, you could fix this by doing some division and modulus on the index.</P>
<P><STRONG>Conditionals</STRONG></P>
<P>The <EM>#if()</EM> statement allows you to conditionally include expressions in your visualizer:</P>
<BLOCKQUOTE dir="ltr" style="MARGIN-RIGHT: 0px"><PRE>MyType {<BR>&nbsp;&nbsp;&nbsp; preview (<BR>        #if (($c.end - $c.start) &gt; 0) (<BR>            #("size=", $c.end - $c.start)<BR>        )&nbsp;#else (<BR>            "empty"<BR>        )<BR>&nbsp;&nbsp;&nbsp; )<BR>}</PRE></BLOCKQUOTE>
<P>There are also <EM>#else</EM> and <EM>#elif()</EM> statements to do more complex if statements; these are analogous to the C equivalents.</P>
<P>The <EM>#switch()</EM> statement lets you... well, switch. <EM>#case</EM> and <EM>#default</EM> are present, except that there are no fall-throughs and no <EM>break</EM>. You can do some nice hacks using a <EM>#switch</EM>:</P>
<BLOCKQUOTE dir="ltr" style="MARGIN-RIGHT: 0px"><PRE>MyType {
    children (
        #switch($c.start[0].flags &amp; 0xf000)
        #case 0x0000 ( #( freed: $c.start[0].value ) )<BR>        #case 0x2000 ( #( alloc: $c.start[0].value ) )<BR>        #case 0x3000 ( #( active: $c.start[0].value ) )<BR>        #default ( #( huh: $c.start[0].value ) )<BR>&nbsp;&nbsp;&nbsp; )<BR>}</PRE></BLOCKQUOTE>
<P>Two things to note here. One, the <EM>#switch</EM> statement doesn't have a scope around its&nbsp;<EM>#case</EM> statements. Two, it doesn't work within an <EM>#array</EM>. If you try it, devenv will hang at 100% CPU. For those cases, use <EM>#if</EM> instead.</P>
<P><STRONG>Lists</STRONG></P>
<P>Arrays are fine, but sometimes you want to use a linked list. Well, the visualizer supports that:</P>
<BLOCKQUOTE dir="ltr" style="MARGIN-RIGHT: 0px"><PRE>// cpp file<BR>struct MyNode {
    MyNode *prev, *next;
    int value;
};
struct MyList {
    MyList *head;
};
// autoexp.dat
MyList {
    children (
        #list (
            head: $c.head,
            next: next
        )
    )
}</PRE></BLOCKQUOTE>
<P>The visualizer will then proceed to follow the singly-linked list and place each element in the output. Note that the <EM>next</EM>&nbsp;portion denotes a field name in the child node and not an expression.&nbsp;Like <EM>#array</EM>, you can use <EM>#list() : &lt;expr&gt;</EM> syntax to change the way each <EM>$e</EM> is displayed.</P>
<P><EM>#list</EM> is protected against infinite traversals and will cope gracefully with a circular list. Also, you can use a <EM>skip:</EM> expression to&nbsp;denote&nbsp;a sentinel node that&nbsp;should not be reported. Although the name implies that the node will be skipped, it actually causes traversal to stop, so if your sentinel node is first you should start traversal after it.</P>
<P>You can also supply a <EM>size:</EM> expression to limit the number of elements displayed.</P>
<P><STRONG>Trees</STRONG></P>
<P>Ah, now for the really evil stuff: trees.</P>
<BLOCKQUOTE><PRE>struct TreeNode {
    TreeNode *left, *right;
    int value;
};
struct TreeTest {
    TreeNode *head;
    int size;
};
TreeTest {
    children
    (
        #(
            #tree (
                head : $c.head,
                left : left,
                right : right,
                size : $c.size
            ) : &amp;$e
        )
    )
}
</PRE></BLOCKQUOTE>
<P>In this case, Visual Studio trawls the tree using in-order traversal: that is, left, then current, then right. As with #list, <EM>size:</EM> can be an expression limiting the node count, <EM>skip:</EM> can avoid sentinels, and a value expression is possible.</P>
<P>There is a nasty bug with the <EM>#list</EM> and <EM>#tree</EM> statements you should be aware of: they do not work if the nodes exist in static storage in a module. The traversal will work OK, but the <EM>$e</EM> variable will point to an invalid offset instead of the actual item, and you won't be able to see any of the elements. I got burned by this when I tried to write a visualizer to dump the list of critical sections in the process, which turns out to reside in a static block in ntdll.dll, and I don't have a workaround yet.&nbsp;This bug does not affect the <EM>#array</EM> primitive.</P>
<P><STRONG>The string view expression</STRONG></P>
<P><EM>stringview</EM> is an odd one: it sets the string that is displayed in the Text, XML, or HTML visualizer. This is what shows up when you click the little magnifying glass on the right side of some entries, like strings. Sadly, this is not terribly useful as all of the text visualizers are modal, but otherwise, it has the same syntax as the regular <EM>preview</EM> block.</P>
<BLOCKQUOTE><PRE>StringTest {
    stringview ( "&lt;HTML&gt;&lt;FONT color=red&gt;HTML output!!&lt;/FONT&gt;" )
}
</PRE></BLOCKQUOTE>
<P>The usefulness of this is unfortunately damped by two limitations: you can't escape HTML symbols in strings you output, and you can't put literal strings in the value expressions evaluated by, say,&nbsp;<EM>#array</EM> or <EM>#list</EM>, as they evaluate to NULL. You can't generate an XML or HTML report from a data structure.&nbsp;It's really only useful if you already have HTML or XML somewhere in memory.</P>
<P><STRONG>Real examples</STRONG></P>
<P>One common container that you might write yourself, and want to view, is a hash table: a&nbsp;nice hash table, consisting of a&nbsp;prime number of buckets, and a linked list at&nbsp;each one.&nbsp;Good luck finding anything in a hash table that has 500 buckets, though, so it's perfect for a visualizer. Unfortunately, if you look at the visualizer for <EM>stdext::hash_set</EM>, you'll discover that the VC guys cheated -- the Dinkumware STL has a single linked list binding all nodes in the hash_set, and just trawled it with a <EM>#list</EM>. We have an array of singly linked lists to elements.</P>
<P>Can we crawl such a structure? You bet!</P>
<BLOCKQUOTE><PRE>struct Node {
    Node *next;
    int value;
};
struct HashSet {
    Node **buckets;
    int bucketCount;
};
// autoexp.dat
HashSet {
    children (
        #(
            #array (
                expr : ($c.buckets)[$i],
                size : $c.bucketCount
            ) : #(
                #list (
                    head : $e,
                    next : next
                ) : $e.value
            )
        )
    )
}</PRE></BLOCKQUOTE>
<P>Another tricky example: say you have an array&nbsp;of pointers, but want to skip the entries that are NULL. Can we do it? Sure!</P>
<BLOCKQUOTE><PRE>struct SparseArray {
    void **start, **end;
};
// autoexp.dat
SparseArray {
    children(
        #array (
            expr: $c.start[$i],
            size: $c.end - $c.start
        ) : #if ($e != 0) (
            $e
        )
    )
}
</PRE></BLOCKQUOTE>
<P>And here it is in the debugger:</P>
<P style="text-align:center;"><IMG src="./Writing custom visualizers for Visual Studio 2005 - virtualdub.org_files/debuggercrash.png" border="0" title="[Visual Studio debugger crash]" alt="[Visual Studio debugger crash]"></P>
<P>Ehh... hmmm. Well, as it turns out, doing an asymmetric <EM>#if</EM> within an <EM>#array</EM> causes the debugger to blow up. It is possible to do this, but only with a big hack:</P>
<BLOCKQUOTE><PRE>SparseArray {
    children(
        #(
            #array (
                expr: &amp;$c.start[$i],
                size: $c.end - $c.start
            ) : #(
                #array (
                    expr: &amp;$e,
                    size: $e != 0
                ) : $e
            )
        )
    )
}
</PRE></BLOCKQUOTE>
<P>Hee-haw!</P>
<P><STRONG>Conclusion</STRONG></P>
<P>The new visualizers are much more powerful in their capabilities, and open up a lot of possibilities for interesting debug displays within the Visual Studio Debugger. It sorely needs to be documented, and it can be a bit unstable when you work with it, but in general it makes data structures a lot nicer to work with.</P>
<P>(<STRONG>Update 9/27/2007:</STRONG> See my <A href="http://www.virtualdub.org/blog/pivot/entry.php?id=172">followup note</A>.)</P> <DIV class="entryfooter"> 69 comments | Jul 24,  2006 at 02:08 | default</DIV></DIV> <DIV class="content" style="margin-top: 16px"> <H3>Comments</H3> <P><B>Comments posted:</B></P><A id="comm"></A><HR>I guess it was so long underadvertised, because it was quite unusuable in the MSVC6 days. You added your nice little STL size and content stuff, but the debugger would just lock up or even crash, because for some reason it couldn't handle the macros in a lot of cases. In some cases I even wasted hours on those hangs or crashes, because I thought it was my application having something like an endles recursion/stack overflow or even something worse. And at the end it turned out, I just had to remove all the helpful stuff from the autoexp.dat to get it working again. Pretty helpful...<P><SMALL><B>Firewave</B>   - 14 08 06 - 04:50</SMALL></P><HR>I've got a string class that uses non-null-terminated strings.  I'd love to see a way to display a range of characters in the debugger -- the normal ",s" watch expression shows the buffer guards past the end of the string.  Any idea how to do that?<P><SMALL><B>Michael</B>   - 26 09 06 - 21:14</SMALL></P><HR>I'm afraid not. I would suggest the preview block, but there's no way to push out a character by itself. Traditionally STL basic_string implementations maintain a null at the end in order to speed up c_str(), so they don't have this problem.<P><SMALL><B>Phaeron</B>   - 26 09 06 - 23:39</SMALL></P><HR>Thankyou for this article, i've been using autoexp.dat for years but it's never been able to evaluate the kind of expressions I need to access the data types used by Alias's Maya SDK. Now I can finally see the contents of those MStrings without nasty debug code!<P><SMALL><B>Fraser Graham</B>   - 04 10 06 - 18:22</SMALL></P><HR>That was a really useful article! Do you know if it's possible to display a matrix, ie have a #array nested inside a #array and display the correct number of things. If so, how do you tell it to access element [i][j]? It's almost hinted at in your hack to skip the NULLs but not quite.<P><SMALL><B>Dave</B>   - 14 11 06 - 12:51</SMALL></P><HR>The only way I know of to do a multidimensional matrix is to use #array with 'rank'; if you try nesting #array statements then the debugger will just flatten the result. The downside to using rank for this is that it displays the indices in reverse order from normal C conventions. According to one of the guys on the VC++ team, this is a bug. It also means your matrix has to be contiguous.<BR>
<BR>
If you have a fixed-size matrix, then you should simply be able to use an #array with something like [$e,10] for each element.<P><SMALL><B>Phaeron</B>   - 15 11 06 - 23:46</SMALL></P><HR>Great article!!  I've been experimenting with autoexp.dat visualizers to display out own types, and have been successful at creating expressions which can display our custom types.  However, almost every debug session, I get the crash mentioned in your article and I have to close VS through task manager.  The crashes occur in seemingly random places; at the same code location, sometimes it will crash and sometimes it won't.  I haven't been able to narrow down which of the 5 or 6 visualizer expressions is the culprit.  Do you have any pointers for tracking down / debugging these crashes to determine which visualizer expression is causing the problem?<P><SMALL><B>Ron</B>   - 17 01 07 - 14:59</SMALL></P><HR>Nope, afraid not. The best I could suggest is to attach another instance Visual Studio to the bombed one with the Microsoft symbol server hooked up and see if you get lucky with the call stack.<P><SMALL><B>Phaeron</B>   - 17 01 07 - 23:16</SMALL></P><HR>Great article!  The best on the subject on the net at this moment.  Note that I've found 1 behavior (somewhat bug) and 1 bug with visualizers that have forced us to modify our usage of them.  First, pointers are previewed/expanded as their pointed type (Type* like Type).  We have then decide to start all previews with the object address (casted as void* to avoid recursive evaluation).  Second, Type[x] is previewed/expanded exactly like Type.  This is a particularly bad when "children" is overridden and the array elements cannot be accessed as before.  We have then decide to only override "children" for types that we don't expect in a C array.  Visualizers will be more useful once this is fixed (I haven't tried SP1 yet).<P><SMALL><B>Nicolas Fleury</B>   - 12 04 07 - 15:41</SMALL></P><HR>I'm having a problem getting STLPORT containers to work.  The core of the issue is that the containers point to and iterate with 'node_base' (which contain the link pointers), but the data is in the subclass 'node'.  If I try something like:<BR>
	#list<BR>
	(<BR>
		head : $c._M_node._M_data-&gt;_M_next, <BR>
		skip : $c._M_node._M_data, <BR>
		next : _M_next<BR>
	) : (_STL::_List_node*) &amp;$e<BR>
It gives me "error | 0" when inspecting the children.  Anybody have success with using the template parameters when casting?<P><SMALL><B>Ian</B>   - 17 04 07 - 22:56</SMALL></P><HR>"_STL::_List_node" is actually templatized on $T1 in the previous comment.<P><SMALL><B>Ian</B>   - 17 04 07 - 22:58</SMALL></P><HR>The parser can be a bit finicky sometimes, and occasionally wrapping expressions in parens, brackets, or #() can coax it into behaving. In your case, though, the space between the cast and the &amp;$e may be your problem. When using bare expressions in visualizers, it's usually best to avoid all unnecessary spaces.<P><SMALL><B>Phaeron</B>   - 18 04 07 - 00:44</SMALL></P><HR>Does anyone have any tips on getting boost::shared_ptr to display nicely in the debugger?<BR>
If the px member of the ptr shows: 0x02539f08 {"G:somepathName"}<BR>
And I write:<BR>
boost::shared_ptr&lt;MyPathType&gt;{<BR>
preview($c.px)<BR>
}<BR>
<BR>
I would expect to see the same display for my shared pointer preview that the px member shows, but all I see is the memory address: {0x02539f08}<P><SMALL><B>Matt</B>   - 19 04 07 - 17:03</SMALL></P><HR>Awesome. AutoExp.dat is more empowered and you explained the enhancements quite nicely. In fact I was looking for details on AutoExp.dat and I got only this link that explains about visualizer section. Thanks for this as it simplified the 'good for nothing' visual represntation of a unicode string container in the debugger, I work with, everyday.<P><SMALL><B>Naren Chauhan</B>   - 04 05 07 - 05:13</SMALL></P><HR>I've cloned std:vector to get MFC CArray working but I'd like to be able to view a particular element of a vector or CArray. Any ideas on this?<P><SMALL><B>paul tait</B>   - 15 06 07 - 00:06</SMALL></P><HR>Try this for stlport lists,<BR>
<BR>
stlp_std::list{<BR>
	children<BR>
	(<BR>
		#list<BR>
		(<BR>
			head : $c._M_node._M_data._M_next,<BR>
			skip : &amp;($c._M_node._M_data),<BR>
			next : _M_next<BR>
		) : #( *($T1 *)(sizeof(stlp_std::priv::_List_node_base)+((char*)&amp;($e))) )<BR>
	)<BR>
	preview<BR>
	(<BR>
		#(<BR>
			"(",<BR>
			#list<BR>
			(<BR>
				head : $c._M_node._M_data._M_next,<BR>
				skip : &amp;($c._M_node._M_data),<BR>
				next : _M_next<BR>
			) : *($T1 *)(sizeof(stlp_std::priv::_List_node_base)+((char*)&amp;($e))),<BR>
			")"<BR>
		)<BR>
	)<BR>
}<BR>
<BR>
It's a hack, I know, but I can't seem to cast to templated types. Similar stuff works for sets, but because I can't cast to templated types I can't find a way to show both keys and values in maps (I've gone for just showing the value).<P><SMALL><B>Dave B</B>   - 26 06 07 - 23:04</SMALL></P><HR>Darn, the angle brackets have been eaten. It's actually<BR>
stlp_std::list[*,*] - with the square brackets as angle brackets<BR>
And the #( ... ) in the children section shouldn't be there, and will crash VS2005 if it's left in!!<P><SMALL><B>Dave B</B>   - 26 06 07 - 23:27</SMALL></P><HR>Did anybody managed to get stl port's map visualized ?<BR>
I think I will give it up, I tried all day long.<BR>
stlp_std::map<P><SMALL><B>Mark S</B>   - 26 07 07 - 13:43</SMALL></P><HR>As this seems to be the only source of information that I can find on the net for autoexp.dat under vs 8 I thought I'd add my visualiser for stlport maps:<BR>
<BR>
stlp_std::map {<BR>
    children<BR>
    (<BR>
        #(<BR>
			[map]: [$c,!],<BR>
            #tree (<BR>
                head : $c._M_t._M_header._M_data._M_parent,<BR>
                left : _M_left,<BR>
                right : _M_right,<BR>
                skip : $c._M_t._M_header._M_data<BR>
            ) : *($T2*)(sizeof($T1)+sizeof(stlp_std::_Rb_tree_node_base)+((char*)(&amp;$e)))<BR>
              ; *($T1*)(sizeof(stlp_std::_Rb_tree_node_base)+((char*)(&amp;$e)))<BR>
	          ; *($T2*)(sizeof($T1)+sizeof(stlp_std::_Rb_tree_node_base)+((char*)(&amp;$e)))<BR>
        )<BR>
    )<BR>
}<BR>
<BR>
I've commented the two lines at the end because you can either show the key or the value. I've not yet managed to show both on the same line (showing them as consecutive entries doesn't cut it for me). I've tried showing them as a pair but it's not having it so any other suggestions gratefully received.<P><SMALL><B>Alex Whittaker</B>   - 27 07 07 - 07:36</SMALL></P><HR>Bah, why has no one written a decent text to HTML converter? Try again, a bit more readable this time:<BR>
<BR>
stlp_std::map {<BR>
children<BR>
(<BR>
#(<BR>
[map]: [$c,!],<BR>
#tree (<BR>
head : $c._M_t._M_header._M_data._M_parent,<BR>
left : _M_left,<BR>
right : _M_right,<BR>
skip : $c._M_t._M_header._M_data<BR>
) : *($T2*)(sizeof($T1)+sizeof(stlp_std::_Rb_tree_node_base)+((char*)(&amp;$e)))<BR>
; *($T1*)(sizeof(stlp_std::_Rb_tree_node_base)+((char*)(&amp;$e)))<BR>
; *($T2*)(sizeof($T1)+sizeof(stlp_std::_Rb_tree_node_base)+((char*)(&amp;$e)))<BR>
)<BR>
)<BR>
}<P><SMALL><B>Alex Whittaker</B>   - 27 07 07 - 07:55</SMALL></P><HR>This is what I did to stlp set.  It only works for the last type of set declared.  If I declared set&lt; int &gt;, then set&lt; string &gt;, then only set&lt; string &gt; will display correctly.  Any insight?  Thanks.<BR>
<BR>
	children<BR>
	(<BR>
		#tree<BR>
		(<BR>
			head : $c._M_t._M_header._M_data._M_parent, <BR>
			skip : $c._M_t._M_header._M_data, <BR>
			left : _M_left, <BR>
			right : _M_right,<BR>
			size  : $c._M_t._M_node_count<BR>
		) : ((_Node*)(&amp;$e))-&gt;_M_value_field<BR>
	)<P><SMALL><B>Liu</B>   - 24 08 07 - 19:38</SMALL></P><HR>Hey good article, I have a question though. Is there any way to add types to the view menu? You know, when you right click on the watch window and it brings up a sub menu that lets you change how to view variables of the numeric type. I want to add a new view to it, instead of viewing my values in hex and such, I want to view them in a fix point format. Can this be done?<P><SMALL><B>Andre B</B>   - 30 08 07 - 15:04</SMALL></P><HR>Great stuff here. I will be able to use this a lot.<BR>
People interested in visualizers might also be interested in a graphical viewer for C/C++-arrays (even in unmanaged code!) which I wrote.<BR>
See <A href="http://arraydebugview.sourceforge.net/">http://arraydebugview.sourceforge.net</A><P><SMALL><B>Joachim</B>   - 12 09 07 - 18:28</SMALL></P><HR>Here is a visualizer for STLPort strings<BR>
<BR>
stlp_std::basic_string {<BR>
preview<BR>
(<BR>
#(<BR>
#if ($c._M_end_of_storage._M_data == $c._M_buffers._M_static_buf + $c._DEFAULT_SIZE)<BR>
(<BR>
$c._M_buffers._M_static_buf<BR>
) #else (<BR>
$c._M_buffers._M_dynamic_buf<BR>
)<BR>
)<BR>
)<BR>
}<P><SMALL><B>Kevin</B>   - 20 09 07 - 15:06</SMALL></P><HR>Hi<BR>
<BR>
Thanks to the very useful information I found here I have been able to write a rather complete autoexp.dat for the STLport library. You will find it in SVN trunk of the STLport sourceforge project here:<BR>
<BR>
<A href="https://sourceforge.net/projects/stlport/">https://sourceforge.net/projects/stlport..</A><BR>
<BR>
Bests<P><SMALL><B>Dums</B>   - 31 10 07 - 17:23</SMALL></P><HR>I’ve got a string class that uses non-null-terminated strings. I’d love to see a way to display a range of characters in the debugger—the normal ”,s” watch expression shows the buffer guards past the end of the string. Any idea how to do that?<P><SMALL><B>Articles</B>   - 11 11 07 - 04:42</SMALL></P><HR>Great article!! I’ve been experimenting with autoexp.dat visualizers to display out own types, and have been successful at creating expressions which can display our custom types. However, almost every debug session, I get the crash mentioned in your article and I have to close VS through task manager. The crashes occur in seemingly random places; at the same code location, sometimes it will crash and sometimes it won’t. I haven’t been able to narrow down which of the 5 or 6 visualizer expressions is the culprit. Do you have any pointers for tracking down / debugging these crashes to determine which visualizer expression is causing the problem?<P><SMALL><B>Articles</B>   - 12 11 07 - 09:34</SMALL></P><HR>Reverse engineering at its best!  thanks for putting this online.<BR>
It might be useful to note that a checkbox needs to be cleared in VS(2005) :Options/Debugging/General/"Show raw structure of objects.." . checking this bypasses loading autoexp.dat altogether.<BR>
And a question - can you say what the 'b' format suffix does?  (as in [$c.foo, sub])<P><SMALL><B>Ofek</B>   - 23 01 08 - 10:53</SMALL></P><HR>The b suffix gives you the bare representation of the object. I haven't explored what it does in all cases, but for strings (s, su, and s8), it suppresses the quotes that ordinarily appear around the string.<P><SMALL><B>Phaeron</B>   - 23 01 08 - 23:32</SMALL></P><HR>Thanks! <BR>
<BR>
also - i have a method to visualize multiple members of an array element *without* bumping the indices up: write a custom preview to the array element, to view it's members (or part of them) in a single line.<BR>
<BR>
You can take this further in some cases, to make fake 2d visualizers. example c++ source (D3D-like matrix):<BR>
<BR>
struct MATRIX{<BR>
	FLOAT        _11, _12, _13, _14;<BR>
	FLOAT        _21, _22, _23, _24;<BR>
	FLOAT        _31, _32, _33, _34;<BR>
	FLOAT        _41, _42, _43, _44;<BR>
	};<BR>
<BR>
modify to-<BR>
<BR>
struct MatrixLine<BR>
	{	FLOAT f1, f2, f3, f4; };<BR>
struct MATRIX<BR>
	{<BR>
	union {<BR>
		struct {<BR>
			FLOAT        _11, _12, _13, _14;<BR>
			FLOAT        _21, _22, _23, _24;<BR>
			FLOAT        _31, _32, _33, _34;<BR>
			FLOAT        _41, _42, _43, _44;<BR>
			};<BR>
		MatrixLine line[ 4 ];<BR>
	};<BR>
<BR>
and add to autoexp - <BR>
MatrixLine{<BR>
	preview(#($c.f1,", ",$c.f2,", ",$c.f3,", ",$c.f4))<BR>
	children([$c,!])<BR>
}<BR>
<BR>
to get a nice 2d layout of the matrix.<BR>
<BR>
To keep the watch edit-access, it's important to keep the children block (previewed data isn't editable).<P><SMALL><B>Ofek</B>   - 25 01 08 - 09:25</SMALL></P><HR>Annoying gotcha to the matrix transformation: anonymous structs are a Visual C++ specific language extension. Standard C++ only supports anonymous unions. Kinda sucks, at least for math libraries.<P><SMALL><B>Phaeron</B>   - 26 01 08 - 21:41</SMALL></P><HR>I'm having a problem getting custom visualizers to work.  I placed a new section in autoexp.dat and followed the instructions here, but I don't see any effect in my watch windows.  I know that my changes are being read in, because when I made syntax errors I was notified and fixed them.  What could be going wrong?  The typenames I'm using are identical to those displayed in the "Type" column of the watch window.<P><SMALL><B>Luke</B>   - 11 06 08 - 21:07</SMALL></P><HR>I figured out the answer to my question.  It turns out that the file format is whitespace-sensitive.  You have to have the opening curly brace on the same line.  D'oh!<P><SMALL><B>Luke</B>   - 24 06 08 - 21:21</SMALL></P><HR>Hi all,<BR>
Thanks for the great article , I found it most useful as i work with CMaps a lot !<BR>
However, i was wondering if there was a way to display meaningful values of a <BR>
CTypedPtrArray ? I have something declared this way : <BR>
<BR>
CTypedPtrArray *&gt; mymap;<BR>
<BR>
All i can get is a CPtrArray member and a numeric value (address of mymap i guess...)<BR>
<BR>
Thanks<P><SMALL><B>RAM</B>   - 25 09 08 - 08:04</SMALL></P><HR>Oooops, i didn't notice the small print comment at the end of the page...<BR>
Here is the array declaration with '{' and '}' instead of 'less than' and 'greater than':<BR>
<BR>
CTypedPtrArray { CPtrArray ,CMap { CString, LPCSTR, CString, LPCSTR } *} mMapPageScopeID;<BR>
<BR>
Thanks<P><SMALL><B>RAM</B>   - 25 09 08 - 08:09</SMALL></P><HR>Out of curiosity, how did you figure all this out?  We're using quite a few complex visualizers (which we were able to create thanks to your information), but they occasionally cause VS to crash (usually right when I reach the critical line that will reveal the source of the bug, heh).  I'm unsure how to go about figuring out which part of the visualizer (or even <B>which</B> visualizer) is causing the problem....<P><SMALL><B>Ron Prestenback</B>   - 17 10 08 - 14:51</SMALL></P><HR>I'm afraid I just sat down, studied the existing visualizers, and experimented with writing new ones.<BR>
<BR>
What usually causes the crashes is infinite recursion -- just about everything else will either give you a parse error dialog or display (error) in the watch window. Do watch out for the change in SP1 that affects $c vs. $e, which I noted in the followup. That'll give you hard to find errors since the blow ups will only occur when visualizers are nested.<P><SMALL><B>Phaeron</B>   - 18 10 08 - 00:43</SMALL></P><HR>Here is a visualizer for boost::unordered_map(which I've spent a whole afternoon to work it out):<BR>
<BR>
boost::unordered_map{<BR>
    preview<BR>
    (<BR>
        #(<BR>
            "[", $e.base.data_.size_, "](",<BR>
            #array<BR>
            (<BR>
                expr : $e.base.data_.buckets_[$i],<BR>
                size : $e.base.max_load_,<BR>
            ) : #(<BR>
                #array (<BR>
                    expr: $e,<BR>
                    size: $e.next_ != 0<BR>
                ) : #(<BR>
                    #list(<BR>
                        head : $e.next_,<BR>
                        next : next_<BR>
                    ) : ((boost::unordered_detail::hash_table_data_unique_keys::node*)&amp;$e)-&gt;value_<BR>
                )<BR>
            ),<BR>
            ")"<BR>
        )<BR>
    )<BR>
    children<BR>
    (<BR>
        #(<BR>
            [raw members]: [$c,!],<BR>
            #array<BR>
            (<BR>
                expr : $e.base.data_.buckets_[$i],<BR>
                size : $e.base.max_load_,<BR>
            ) : #(<BR>
                #array (<BR>
                    expr: $e,<BR>
                    size: $e.next_ != 0<BR>
                ) : #(<BR>
                    #list(<BR>
                        head : $e.next_,<BR>
                        next : next_<BR>
                    ) : ((boost::unordered_detail::hash_table_data_unique_keys::node*)&amp;$e)-&gt;value_<BR>
                )<BR>
            )<BR>
        )<BR>
    )<BR>
}<BR>
<BR>
And you can find more visualizers for boost ptr_containers at<BR>
<BR>
<A href="http://lists.boost.org/boost-users/2007/04/27051.php">http://lists.boost.org/boost-users/2007/..</A><P><SMALL><B>zhaowei</B>   - 25 10 08 - 13:24</SMALL></P><HR>Sorry, it should be:<BR>
<BR>
boost::unordered_map{<BR>
...<BR>
}<P><SMALL><B>zhaowei</B>   - 25 10 08 - 13:28</SMALL></P><HR>Hello,<BR>
<BR>
This is a very interesting article. Do you know if there is a way to make use of global variables in visualizers? Some of my data structures make use of a global variable and I need to access it to fully display the content of an element. <BR>
<BR>
More precisely, my data structure contains 16-bit indexes into a global object array. To fully display the data structure, I need to access the global array. I have tried to refer to the global variable as $V or V, but it doesn't work...<P><SMALL><B>Alexandre</B>   - 04 11 08 - 03:42</SMALL></P><HR>Hi, <BR>
<BR>
This is a very nice article, the best I can find about autoexp.dat. <BR>
<BR>
Has anybody come up with a visualizer for boost::any? <BR>
<BR>
It is a useful class but difficult to be debugged. <BR>
<BR>
Thanks<BR>
<BR>
Yuan<P><SMALL><B>Yuan Li</B>   - 22 12 08 - 02:59</SMALL></P><HR>Really helpful article; thanks! I'm posting here in case anyone else is ever looking like I was for a way to show Rogue Wave strings (RWCString) properly in the debugger. The string itself can be exposed using the AutoExpand section, but since they store their length in a funky way it was impossibly to show that. The Visualizer section changes that though:<BR>
<BR>
RWCString {<BR>
   preview (<BR>
      #("{",<BR>
         [$c.data_,st],<BR>
         " length=", strlen($c.data_<BR>
         [(((RWCStringRef*)$c.data_)-1)-&gt;nchars_,u],<BR>
         "}"<BR>
      )<BR>
   )<BR>
}<P><SMALL><B>Owen</B>   - 07 01 09 - 18:06</SMALL></P><HR>Visual C++ 2008<BR>
Boost 1.36.0<BR>
<BR>
boost::unordered_map visualizer described by zhaowei doesn't work for me... I've tested with boost::unordered_map.<P><SMALL><B>dlaugt</B>   - 08 01 09 - 05:44</SMALL></P><HR>boost::unordered_map&lt;int, int&gt;<BR>
<BR>
boost::unordered_map&lt;int, int&gt; entities;<BR>
entities[0] = 10;<BR>
entities[1] = 11;<BR>
entities[2] = 12;<BR>
entities[3] = 13;<P><SMALL><B>dlaugt</B>   - 08 01 09 - 06:41</SMALL></P><HR>At the end of #list, $e has the correct address but it will not be able to cast into node*<BR>
((boost::unordered_detail::hash_table_data_unique_keys::node*)&amp;$e)-&gt;value_<P><SMALL><B>dlaugt</B>   - 08 01 09 - 08:25</SMALL></P><HR>Nice article. I'm running VC9SP1 and find that I need to restart the devenv to see my changes to autoexp.dat. Anybody else seeing this? This is with a native C++ project - if that matters.<P><SMALL><B>Paul</B>   - 13 01 09 - 18:05</SMALL></P><HR>Yes, I did start seeing that once I'd upgraded to SP1. I think it only happens sometimes, but I might be wrong.<P><SMALL><B>Phaeron</B>   - 14 01 09 - 01:00</SMALL></P><HR>In case you are interested in a boost::shared_ptr (smart pointer) visualizer, you can find one here:<BR>
<BR>
<A href="http://code.msdn.microsoft.com/boostsharedptrvis">http://code.msdn.microsoft.com/boostshar..</A><P><SMALL><B>CppGuy</B>   - 29 01 09 - 06:32</SMALL></P><HR>I had my own problems with stlport sets and maps, since the autoexp that comes with stlport supports version 5.2 and I'm still using 5.1. They use one visualizer for sets and maps, but maps don't work as expected. Here is how to fix this without using casts to stlport structs.<BR>
<BR>
set needs to be declared with two or three template parameters, if you have only one the visualizer won't work.<BR>
#tree<BR>
(<BR>
    head : $c._M_t._M_header._M_data._M_parent,<BR>
    skip : $c._M_t._M_header._M_data,<BR>
    left : _M_left,<BR>
    right : _M_right<BR>
) : *($T1*)(&amp;($e) + 1)<BR>
<BR>
this works in both preview and children expression<BR>
<BR>
map needs to be declared with three or four template parameters, it' won't work with one or two<BR>
<BR>
#tree<BR>
(<BR>
    head : $c._M_t._M_header._M_data._M_parent,<BR>
    skip : $c._M_t._M_header._M_data),<BR>
    left : _M_left,<BR>
    right : _M_right<BR>
) : *(stlp_std::pair*)(&amp;($e) + 1)<BR>
<BR>
this works in children expression but to make it work in preview you need to change stlp_pair visualizer to have only one template parameter and to dereference first and second with $e variable instead of $c. This is how MS implemented their visualizer for pair and they should know how this works ;)<BR>
<BR>
This was tested with Visual Studio 2008 SP1<P><SMALL><B>Nikola Smiljanic</B>   - 10 03 09 - 04:37</SMALL></P><HR>damn html<BR>
<BR>
#tree<BR>
(<BR>
head : $c._M_t._M_header._M_data._M_parent,<BR>
skip : $c._M_t._M_header._M_data,<BR>
left : _M_left,<BR>
right : _M_right<BR>
) : *(stlp_std::pair[$T1 const ,$T2]*)(&amp;($e) + 1)<BR>
<BR>
use angle brackets instead of square ones, spaces are very important: one before and one after const, and no space after comma (it won't work otherwise)<P><SMALL><B>Nikola Smiljanic</B>   - 11 03 09 - 10:06</SMALL></P><HR>I have a multidimensional (2D) template array where I want to preview the values of the array.<BR>
Does anybody know a solution for that problem?<P><SMALL><B>zack</B>   - 03 05 09 - 09:20</SMALL></P><HR>Great article! Helped me a lot!<BR>
<BR>
Maybe some will find his useful: Just had a little problem with a virtual array build of partial array chunks that are in a tree structure. But I wanted to see all entries with contiguous indices. Works like this:<BR>
<BR>
	children (#(<BR>
		#tree(<BR>
			head: $e._data,<BR>
			left: before,<BR>
			right: after<BR>
		) : #array( <BR>
			expr: (($T1*)($e._data))[$i + $e._skip], <BR>
			size: $e._fill<BR>
		) : $e,<BR>
		#(<BR>
		[_raw]: [$e,!],<BR>
		[blocks]: #tree(<BR>
			head: $e._data,<BR>
			left: before,<BR>
			right: after<BR>
		)<BR>
		)<BR>
	))<BR>
<BR>
The #() trick you metioned gets the named items after the list, so that the list starts at 0 and the ": $e" after the #array has the effect of disabling the automatic index reset for each array. Without it the numbers would start at 0 (or base) again for each branch of the tree.<BR>
<BR>
<I>PS: Maybe you could also allow the &lt;pre&gt; or &lt;code&gt; html tag</I><P><SMALL><B>Zillatron</B>   - 13 05 09 - 09:21</SMALL></P><HR>@zack: Details? If you post the data part of the template ...<BR>
<BR>
If your template(s) look anything like this:<BR>
<BR>
template&lt; class Elem, int size &gt;<BR>
class TA {<BR>
public:<BR>
	Elem	data[ size ];<BR>
};<BR>
<BR>
template&lt; class Elem, int size1, int size2 &gt;<BR>
class TA2 {<BR>
public:<BR>
	TA&lt; Elem, size1 &gt;	data2[ size2 ];<BR>
};<BR>
<BR>
then this solution works:<BR>
<BR>
TA&lt;*,*&gt;{<BR>
	preview (#(<BR>
		"(",<BR>
		#array( <BR>
			expr: $e.data[$i], <BR>
			size: $T2<BR>
		),<BR>
		")"<BR>
	))<BR>
	children (<BR>
		#array( <BR>
			expr: $e.data[$i], <BR>
			size: $T2<BR>
		)<BR>
	)<BR>
}<BR>
TA2&lt;*,*,*&gt;{<BR>
	preview (#(<BR>
		#array( <BR>
			expr: $e.data2[$i], <BR>
			size: $T3<BR>
		)<BR>
	))<BR>
	children (<BR>
		#array( <BR>
			expr: $e.data2[$i], <BR>
			size: $T3<BR>
		)<BR>
	)<BR>
}<P><SMALL><B>Zillatron</B>   - 27 05 09 - 06:19</SMALL></P><HR>Hi,<BR>
<BR>
is there any possibility to make the visualizer show the most derived object instead of the base class?<BR>
Example<BR>
<BR>
class A {...};<BR>
class B : public A {...};<BR>
class C {A* _a;};<BR>
<BR>
visualizer<BR>
C{<BR>
  preview:( $e._a )<BR>
}<BR>
<BR>
I would prefer to see<BR>
- (A*)($e._a) if $e._a is of type A but not of type B<BR>
- (B*)($e._a) if $e._a is of type B<BR>
For now I always get the base class view<P><SMALL><B>steach</B>   - 29 05 09 - 06:54</SMALL></P><HR><B>@steach</B>: That's one of the things, I'm looking for, too. :(<BR>
<BR>
The only (partial) help is to define a preview for class B. The you'll see this previews after the address of the pointer. For this the debugger analyses the most derived class. But if you say<BR>
| *($e._a)<BR>
you always see the data from the base class, just as if you said <BR>
| *(A*)($e._a)<BR>
<BR>
The same problem is worse in "children". For my smart pointers I'ld like to define something like <BR>
| data: *($e._data)<BR>
but then I only get the base class part of the object they point to. Pretty useless. So I have to use <BR>
| data: $e._data,<BR>
| direct: *($T1*)($e._data)<BR>
If the object is of the templated base class, the the "direct" entry works and I can access the object directly. But if it's of a derived class then I have to use "data" and open there the node for the derived class.<P><SMALL><B>Zillatron</B>   - 03 06 09 - 04:41</SMALL></P><HR>Looking further at the boost libraries you can see an example where User Customer Functions are called out to.<BR>
<BR>
Basically it allows you to call out from a children-block( ) to a custom user function.  This should resolve most peoples problems with displaying partial-strings, etc.  However, it does need the user to press refresh button each time they want an update - and the first time the debugger runs it seems to display "CXX0001: Error: attempting to execute suer function".<BR>
<BR>
// Code to be hash-included everywhere you need to debug<BR>
inline unsigned long long hpp_vizu(int &amp;pt)<BR>
{<BR>
	unsigned long long 	val = pt + 5 ;<BR>
	return val;<BR>
}<BR>
namespace {<BR>
  template struct _print_ptime_helper {<BR>
    _print_ptime_helper() {<BR>
      int pt=0 ;<BR>
      hpp_vizu(pt);<BR>
    }<BR>
  };<BR>
  typedef _print_ptime_helper _print_ptime_helper_2;<BR>
  _print_ptime_helper_2 _print_ptime_helper_2i;<BR>
}<BR>
<BR>
<BR>
; Your script...<BR>
;  T1=*, T2=*<BR>
my_type {<BR>
children (<BR>
  #(  call func: [hpp_vizu($T1),u] ),  ; passing template data in, can access globals too?<BR>
  #(  test: [hpp_vizu(*&amp;($c.array[1])),u] ) ; passing struct data, could do a void * too?<BR>
)<BR>
	<BR>
<BR>
I didnt invent this, its the brilliance of filip konvicka of the Boost project.<BR>
<BR>
1: The visualizer script <BR>
<A href="https://svn.boost.org/svn/boost/sandbox/boost_docs/subprojects/DebuggerVisualizers/boost__DateTime.msvc8.vis.txt">https://svn.boost.org/svn/boost/sandbox/..</A><BR>
<BR>
2: A header file that instantiates an inline function.<BR>
<A href="https://svn.boost.org/svn/boost/sandbox/boost_docs/subprojects/DebuggerVisualizers/date_time_visualizer.hpp">https://svn.boost.org/svn/boost/sandbox/..</A><P><SMALL><B>Lucien Murray-Pitts</B>   - 10 06 09 - 06:55</SMALL></P><HR><B>@Lucien</B>: Thanks, for the hint! <BR>
I tried it and can confirm, that it is possible to call user functions/methods. <BR>
<BR>
With VS 2008 SP1 I always get the error first, but only sometimes with the "refresh" button. So I can't always coax the debugger to call the method again and show the return value. Haven't really figured out the system behind this behavior yet. My first guess is that the refresh button only shows after a step that didn't modify the concerned variable.<P><SMALL><B>Zillatron</B>   - 10 06 09 - 08:56</SMALL></P><HR>Problem: Typecasting "head" in #list with templates.<BR>
<BR>
It seems I (almost) always have to typecast the "head" in a #list. It usually works even with template types. But I can't seem to get it working when i have to use a "$T1" as a template parameter:<BR>
<BR>
Array&lt;*&gt; {<BR>
... #list( <BR>
...... head: (ArrayElement&lt;$T1&gt;*)($e.head),<BR>
<BR>
I tried inserting spaces and braces - nothing seems to work here. Showing it as an ordinary variable value is no problem. Any ideas?<P><SMALL><B>Zillatron</B>   - 22 06 09 - 10:20</SMALL></P><HR>Re: casting ArrayElement&lt;$T1&gt; <BR>
We had the same problem - it seems $T1 can only be used standalone and not as a parameter of another template. <BR>
We solved this by casting to a dummy ArrayElement&lt;int&gt; and later casting from int to (*($T1) &amp;($e.val)) <BR>
Of course you have to make sure the dummy cast does not spoil your traversal of the array/tree/list<P><SMALL><B>iggi</B>   - 06 07 09 - 03:10</SMALL></P><HR><B>@iggi:</B> Thanks for the hint!<BR>
<BR>
I had to reorder my structures a bit, but it works now! :)))<BR>
<BR>
And I found, that $T1 even works as a template argument, when i use it for the element type cast or ordinary variable display. Just not for the "head:" inside the #list. This does the job:<BR>
<BR>
Array&lt;*&gt;{<BR>
...<BR>
#list(<BR>
&nbsp;head : (ArrayElement&lt;DummyType&gt;*)$e.head,<BR>
...<BR>
): (ArrayElement&lt;$T1&gt;*)&amp;$e<P><SMALL><B>Zillatron</B>   - 06 07 09 - 23:50</SMALL></P><HR>Has anybody figured out how to represent doubly-linked lists with no Head.  I have a struct that can either stand alone or be a part of another struct.  It looks something like this:<BR>
<BR>
typedef struct _Stream (<BR>
  struct _Stream *p_next,<BR>
  struct _Stream *p_prev,<BR>
<BR>
  /* the rest of the structure */<BR>
<BR>
) _Stream;<BR>
<BR>
Any ideas on how to make this one work?<P><SMALL><B>rembo666</B>   - 21 07 09 - 06:44</SMALL></P><HR>@<B>rembo</B><BR>
Like our friendly host posted in his original article, something like this:<BR>
<BR>
_Stream{<BR>
children( <BR>
&nbsp;raw: [$e,!],<BR>
&nbsp;#list(<BR>
&nbsp;&nbsp;head: $e.p_next,<BR>
&nbsp;&nbsp;next: p_next,<BR>
&nbsp;&nbsp;skip: $e<BR>
))<BR>
}<BR>
<BR>
should do the trick and show all other elements of the linked list when you open one of them.<P><SMALL><B>Zillatron</B>   - 21 07 09 - 23:01</SMALL></P><HR>hi, exist any way to create visualizer for typedef type (e.g. unsigned long long which represents timestamp in msec). During debugging, it will be perfect show timestamp in human-readeable format, e.g YY-MM-DD hh:mm:ss.sss.<P><SMALL><B>andrei</B>   - 22 09 09 - 21:00</SMALL></P><HR>Hello there.<BR>
Would it be possible to create a plugin for visual studio to show watch variables in an even more flexible way than what autoexp.dat permits ?<P><SMALL><B>Michael</B>  (<A href="http://www.turboirc.com/tp" title="www.turboirc.com/tp">link</A>) - 02 10 09 - 20:43</SMALL></P><HR><B>@andrei:</B><BR>
<BR>
Have a look at the EEAddin sample for VS. It already shows how to display timestamps.<BR>
You probably have to write your own addin and compile it as a dll. Then you can reference it in the autoexp.dat with the $ADDIN definition.<P><SMALL><B>Zillatron</B>   - 08 10 09 - 23:05</SMALL></P><HR>Is there any way to correctly display smart pointers?<BR>
<BR>
My problem is, is that I have a smart pointer object, which has member variables that are also smart pointers.<BR>
<BR>
It looks something like this<BR>
<BR>
typedef smartPtr myType1_ptr;<BR>
typedef smartPtr myType2_ptr;<BR>
<BR>
class myType1<BR>
{<BR>
private:<BR>
    myType2_ptr data;<BR>
};<BR>
<BR>
class myType2<BR>
{<BR>
private:<BR>
    string data;<BR>
}<BR>
<BR>
And I have a secion in autoexp.dat that looks somthing like this<BR>
<BR>
smartPtr{<BR>
	children<BR>
	(<BR>
		#(<BR>
			object : ($T1*)$c.object,<BR>
			orig : [$c,!]<BR>
		)<BR>
	)<BR>
}<BR>
<BR>
myType1{<BR>
  children<BR>
  (<BR>
      #(<BR>
          orig : [$c,!],<BR>
          data : $c.data<BR>
       )<BR>
  )<BR>
}<BR>
<BR>
The problem is, is that in the debugger the variable data shows "error" with a type of int.<BR>
<BR>
Any ideas how I could solve this problem?<P><SMALL><B>Joseph</B>   - 14 10 09 - 03:29</SMALL></P><HR><B>@ Joseph:</B><BR>
could you post the template of smartPtr?<BR>
... and make sure you substitute the angular brackets with their html-encodings (&amp;lt; and &amp;gt;) or they get lost.<BR>
<BR>
what type does the debugger display for "data" when you open the "orig"?<P><SMALL><B>Zillatron</B>   - 14 10 09 - 06:32</SMALL></P><HR>Ok, so I figured out what the problem actually is.<BR>
<BR>
It is a problem with virtual inheritance, and I have almost come to a fix, but now I am having another problem.<BR>
<BR>
So the actual object pointer in the smart_ptr is a base class pointer.<BR>
All of the actual data is on the derived pointer, but since it is virtually derived I cannot simply downcast it, and I dont think the visualizer support dynamic_cast. I can figure out the actual offset of the pointers, but when I do something like this:<BR>
<BR>
derived : (Derived*)(void*)$e.object - 120<BR>
<BR>
The visualizer multiplies the number by 128 so I end up with an offset of much much greater than I want.<BR>
<BR>
Question1: is there anyway to do a dynamic_cast in the visualizer?<BR>
Question2: is there anyway to subtract a pointer address using bytes?<BR>
<BR>
Thanks,<P><SMALL><B>Joseph</B>   - 14 10 09 - 09:12</SMALL></P><HR>Q2: Try <BR>
<BR>
derived : (Derived*)(((char*)$e.object) - 120)<P><SMALL><B>Zillatron</B>   - 14 10 09 - 22:01</SMALL></P></DIV> <DIV class="content" style="margin-top: 16px"> <H3>Comment form</H3> <BR>
<B>Please keep comments on-topic for this entry.</B> If you have unrelated comments about VirtualDub, the forum is a better place to post them.
<FORM method="post" action="http://www.virtualdub.org/blog/pivot/submit.php#message" id="form">
<DIV style="width:100%">
<TABLE border="0" cellspacing="0" cellpadding="0" width="100%" class="commentform">
<TBODY><TR>
      <TD>Name:&nbsp;&nbsp;</TD>
      <TD><INPUT type="text" name="piv_name" size="20" class="commentinput" value=""></TD>
      <TD rowspan="3" valign="top"><DIV style="border-left: 1px solid #000; padding: 4px 8px; margin-left:8px;">Remember personal info?
          <BR>
        <INPUT type="radio" id="remember" name="piv_rememberinfo" value="yes"><LABEL for="remember">Yes</LABEL> <BR>
		<INPUT type="radio" id="forget" name="piv_rememberinfo" value="no" checked="checked"><LABEL for="forget">No</LABEL>
      </DIV></TD>
</TR><TR>
      <TD valign="top">Email (Optional):</TD>
      <TD><INPUT name="piv_email" type="text" size="30" class="commentinput" value=""><BR><SMALL>Your email address is only revealed to the blog owner and is not shown to the public.</SMALL></TD>
      </TR><TR>
      <TD>URL (Optional):</TD>
      <TD><INPUT name="piv_url" type="text" size="30" class="commentinput" value=""></TD>
      </TR><TR><TD colspan="2">Comment:</TD><TD align="right"> /  </TD>
      </TR><TR><TD colspan="3">
<TEXTAREA name="piv_comment" cols="40" rows="5" style="width:99%" class="commentinput"></TEXTAREA></TD></TR>
      <TR>
        <TD colspan="3">
					<INPUT type="hidden" name="piv_code" value="120">
					<INPUT type="hidden" name="piv_weblog" value="phaerons_weblog">
          <P><SMALL><B>An authentication dialog may appear when you click Post Comment.</B> Simply type in "user" as the user.  I have had to do this to stop automated comment spam.</SMALL></P>
          <INPUT type="submit" name="post" value="Post Comment" class="commentbutton" style="font-weight: bold;">
          <INPUT type="submit" name="preview" value="Preview Comment" class="commentbutton">
<BR>
<BR>

        <SMALL><B>Small print:</B> All html tags except &lt;b&gt; and &lt;i&gt; will be removed from your comment. You can make links by just typing the url or mail-address.</SMALL></TD>
      </TR>
</TBODY></TABLE>
</DIV>
</FORM>
</DIV></DIV></BODY></HTML>